// Code generated by counterfeiter. DO NOT EDIT.
package pluginfakes

import (
	"sync"

	"github.com/IBM-Bluemix/bluemix-cli-sdk/bluemix/models"
	"github.com/IBM-Bluemix/bluemix-cli-sdk/plugin"
)

type FakePluginContext struct {
	APIVersionStub        func() string
	aPIVersionMutex       sync.RWMutex
	aPIVersionArgsForCall []struct{}
	aPIVersionReturns     struct {
		result1 string
	}
	aPIVersionReturnsOnCall map[int]struct {
		result1 string
	}
	APIEndpointStub        func() string
	aPIEndpointMutex       sync.RWMutex
	aPIEndpointArgsForCall []struct{}
	aPIEndpointReturns     struct {
		result1 string
	}
	aPIEndpointReturnsOnCall map[int]struct {
		result1 string
	}
	HasAPIEndpointStub        func() bool
	hasAPIEndpointMutex       sync.RWMutex
	hasAPIEndpointArgsForCall []struct{}
	hasAPIEndpointReturns     struct {
		result1 bool
	}
	hasAPIEndpointReturnsOnCall map[int]struct {
		result1 bool
	}
	DopplerEndpointStub        func() string
	dopplerEndpointMutex       sync.RWMutex
	dopplerEndpointArgsForCall []struct{}
	dopplerEndpointReturns     struct {
		result1 string
	}
	dopplerEndpointReturnsOnCall map[int]struct {
		result1 string
	}
	ConsoleEndpointStub        func() string
	consoleEndpointMutex       sync.RWMutex
	consoleEndpointArgsForCall []struct{}
	consoleEndpointReturns     struct {
		result1 string
	}
	consoleEndpointReturnsOnCall map[int]struct {
		result1 string
	}
	UAAEndpointStub        func() string
	uAAEndpointMutex       sync.RWMutex
	uAAEndpointArgsForCall []struct{}
	uAAEndpointReturns     struct {
		result1 string
	}
	uAAEndpointReturnsOnCall map[int]struct {
		result1 string
	}
	UAATokenStub        func() string
	uAATokenMutex       sync.RWMutex
	uAATokenArgsForCall []struct{}
	uAATokenReturns     struct {
		result1 string
	}
	uAATokenReturnsOnCall map[int]struct {
		result1 string
	}
	UAARefreshTokenStub        func() string
	uAARefreshTokenMutex       sync.RWMutex
	uAARefreshTokenArgsForCall []struct{}
	uAARefreshTokenReturns     struct {
		result1 string
	}
	uAARefreshTokenReturnsOnCall map[int]struct {
		result1 string
	}
	RefreshUAATokenStub        func() (string, error)
	refreshUAATokenMutex       sync.RWMutex
	refreshUAATokenArgsForCall []struct{}
	refreshUAATokenReturns     struct {
		result1 string
		result2 error
	}
	refreshUAATokenReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	IAMTokenEndpointStub        func() string
	iAMTokenEndpointMutex       sync.RWMutex
	iAMTokenEndpointArgsForCall []struct{}
	iAMTokenEndpointReturns     struct {
		result1 string
	}
	iAMTokenEndpointReturnsOnCall map[int]struct {
		result1 string
	}
	IAMTokenStub        func() string
	iAMTokenMutex       sync.RWMutex
	iAMTokenArgsForCall []struct{}
	iAMTokenReturns     struct {
		result1 string
	}
	iAMTokenReturnsOnCall map[int]struct {
		result1 string
	}
	IAMRefreshTokenStub        func() string
	iAMRefreshTokenMutex       sync.RWMutex
	iAMRefreshTokenArgsForCall []struct{}
	iAMRefreshTokenReturns     struct {
		result1 string
	}
	iAMRefreshTokenReturnsOnCall map[int]struct {
		result1 string
	}
	RefreshIAMTokenStub        func() (string, error)
	refreshIAMTokenMutex       sync.RWMutex
	refreshIAMTokenArgsForCall []struct{}
	refreshIAMTokenReturns     struct {
		result1 string
		result2 error
	}
	refreshIAMTokenReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	UsernameStub        func() string
	usernameMutex       sync.RWMutex
	usernameArgsForCall []struct{}
	usernameReturns     struct {
		result1 string
	}
	usernameReturnsOnCall map[int]struct {
		result1 string
	}
	UserGUIDStub        func() string
	userGUIDMutex       sync.RWMutex
	userGUIDArgsForCall []struct{}
	userGUIDReturns     struct {
		result1 string
	}
	userGUIDReturnsOnCall map[int]struct {
		result1 string
	}
	UserEmailStub        func() string
	userEmailMutex       sync.RWMutex
	userEmailArgsForCall []struct{}
	userEmailReturns     struct {
		result1 string
	}
	userEmailReturnsOnCall map[int]struct {
		result1 string
	}
	IsLoggedInStub        func() bool
	isLoggedInMutex       sync.RWMutex
	isLoggedInArgsForCall []struct{}
	isLoggedInReturns     struct {
		result1 bool
	}
	isLoggedInReturnsOnCall map[int]struct {
		result1 bool
	}
	CurrentOrgStub        func() models.OrganizationFields
	currentOrgMutex       sync.RWMutex
	currentOrgArgsForCall []struct{}
	currentOrgReturns     struct {
		result1 models.OrganizationFields
	}
	currentOrgReturnsOnCall map[int]struct {
		result1 models.OrganizationFields
	}
	HasOrganizationStub        func() bool
	hasOrganizationMutex       sync.RWMutex
	hasOrganizationArgsForCall []struct{}
	hasOrganizationReturns     struct {
		result1 bool
	}
	hasOrganizationReturnsOnCall map[int]struct {
		result1 bool
	}
	AccountIDStub        func() string
	accountIDMutex       sync.RWMutex
	accountIDArgsForCall []struct{}
	accountIDReturns     struct {
		result1 string
	}
	accountIDReturnsOnCall map[int]struct {
		result1 string
	}
	AccountStub        func() models.Account
	accountMutex       sync.RWMutex
	accountArgsForCall []struct{}
	accountReturns     struct {
		result1 models.Account
	}
	accountReturnsOnCall map[int]struct {
		result1 models.Account
	}
	IMSAccountIDStub        func() string
	iMSAccountIDMutex       sync.RWMutex
	iMSAccountIDArgsForCall []struct{}
	iMSAccountIDReturns     struct {
		result1 string
	}
	iMSAccountIDReturnsOnCall map[int]struct {
		result1 string
	}
	ResourceGroupStub        func() models.ResourceGroup
	resourceGroupMutex       sync.RWMutex
	resourceGroupArgsForCall []struct{}
	resourceGroupReturns     struct {
		result1 models.ResourceGroup
	}
	resourceGroupReturnsOnCall map[int]struct {
		result1 models.ResourceGroup
	}
	CurrentSpaceStub        func() models.SpaceFields
	currentSpaceMutex       sync.RWMutex
	currentSpaceArgsForCall []struct{}
	currentSpaceReturns     struct {
		result1 models.SpaceFields
	}
	currentSpaceReturnsOnCall map[int]struct {
		result1 models.SpaceFields
	}
	HasSpaceStub        func() bool
	hasSpaceMutex       sync.RWMutex
	hasSpaceArgsForCall []struct{}
	hasSpaceReturns     struct {
		result1 bool
	}
	hasSpaceReturnsOnCall map[int]struct {
		result1 bool
	}
	RegionStub        func() string
	regionMutex       sync.RWMutex
	regionArgsForCall []struct{}
	regionReturns     struct {
		result1 string
	}
	regionReturnsOnCall map[int]struct {
		result1 string
	}
	RegionIDStub        func() string
	regionIDMutex       sync.RWMutex
	regionIDArgsForCall []struct{}
	regionIDReturns     struct {
		result1 string
	}
	regionIDReturnsOnCall map[int]struct {
		result1 string
	}
	LocaleStub        func() string
	localeMutex       sync.RWMutex
	localeArgsForCall []struct{}
	localeReturns     struct {
		result1 string
	}
	localeReturnsOnCall map[int]struct {
		result1 string
	}
	TraceStub        func() string
	traceMutex       sync.RWMutex
	traceArgsForCall []struct{}
	traceReturns     struct {
		result1 string
	}
	traceReturnsOnCall map[int]struct {
		result1 string
	}
	ColorEnabledStub        func() string
	colorEnabledMutex       sync.RWMutex
	colorEnabledArgsForCall []struct{}
	colorEnabledReturns     struct {
		result1 string
	}
	colorEnabledReturnsOnCall map[int]struct {
		result1 string
	}
	IsSSLDisabledStub        func() bool
	isSSLDisabledMutex       sync.RWMutex
	isSSLDisabledArgsForCall []struct{}
	isSSLDisabledReturns     struct {
		result1 bool
	}
	isSSLDisabledReturnsOnCall map[int]struct {
		result1 bool
	}
	PluginDirectoryStub        func() string
	pluginDirectoryMutex       sync.RWMutex
	pluginDirectoryArgsForCall []struct{}
	pluginDirectoryReturns     struct {
		result1 string
	}
	pluginDirectoryReturnsOnCall map[int]struct {
		result1 string
	}
	HTTPTimeoutStub        func() int
	hTTPTimeoutMutex       sync.RWMutex
	hTTPTimeoutArgsForCall []struct{}
	hTTPTimeoutReturns     struct {
		result1 int
	}
	hTTPTimeoutReturnsOnCall map[int]struct {
		result1 int
	}
	VersionCheckEnabledStub        func() bool
	versionCheckEnabledMutex       sync.RWMutex
	versionCheckEnabledArgsForCall []struct{}
	versionCheckEnabledReturns     struct {
		result1 bool
	}
	versionCheckEnabledReturnsOnCall map[int]struct {
		result1 bool
	}
	PluginConfigStub        func() plugin.PluginConfig
	pluginConfigMutex       sync.RWMutex
	pluginConfigArgsForCall []struct{}
	pluginConfigReturns     struct {
		result1 plugin.PluginConfig
	}
	pluginConfigReturnsOnCall map[int]struct {
		result1 plugin.PluginConfig
	}
	CommandNamespaceStub        func() string
	commandNamespaceMutex       sync.RWMutex
	commandNamespaceArgsForCall []struct{}
	commandNamespaceReturns     struct {
		result1 string
	}
	commandNamespaceReturnsOnCall map[int]struct {
		result1 string
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakePluginContext) APIVersion() string {
	fake.aPIVersionMutex.Lock()
	ret, specificReturn := fake.aPIVersionReturnsOnCall[len(fake.aPIVersionArgsForCall)]
	fake.aPIVersionArgsForCall = append(fake.aPIVersionArgsForCall, struct{}{})
	fake.recordInvocation("APIVersion", []interface{}{})
	fake.aPIVersionMutex.Unlock()
	if fake.APIVersionStub != nil {
		return fake.APIVersionStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.aPIVersionReturns.result1
}

func (fake *FakePluginContext) APIVersionCallCount() int {
	fake.aPIVersionMutex.RLock()
	defer fake.aPIVersionMutex.RUnlock()
	return len(fake.aPIVersionArgsForCall)
}

func (fake *FakePluginContext) APIVersionReturns(result1 string) {
	fake.APIVersionStub = nil
	fake.aPIVersionReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginContext) APIVersionReturnsOnCall(i int, result1 string) {
	fake.APIVersionStub = nil
	if fake.aPIVersionReturnsOnCall == nil {
		fake.aPIVersionReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.aPIVersionReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginContext) APIEndpoint() string {
	fake.aPIEndpointMutex.Lock()
	ret, specificReturn := fake.aPIEndpointReturnsOnCall[len(fake.aPIEndpointArgsForCall)]
	fake.aPIEndpointArgsForCall = append(fake.aPIEndpointArgsForCall, struct{}{})
	fake.recordInvocation("APIEndpoint", []interface{}{})
	fake.aPIEndpointMutex.Unlock()
	if fake.APIEndpointStub != nil {
		return fake.APIEndpointStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.aPIEndpointReturns.result1
}

func (fake *FakePluginContext) APIEndpointCallCount() int {
	fake.aPIEndpointMutex.RLock()
	defer fake.aPIEndpointMutex.RUnlock()
	return len(fake.aPIEndpointArgsForCall)
}

func (fake *FakePluginContext) APIEndpointReturns(result1 string) {
	fake.APIEndpointStub = nil
	fake.aPIEndpointReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginContext) APIEndpointReturnsOnCall(i int, result1 string) {
	fake.APIEndpointStub = nil
	if fake.aPIEndpointReturnsOnCall == nil {
		fake.aPIEndpointReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.aPIEndpointReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginContext) HasAPIEndpoint() bool {
	fake.hasAPIEndpointMutex.Lock()
	ret, specificReturn := fake.hasAPIEndpointReturnsOnCall[len(fake.hasAPIEndpointArgsForCall)]
	fake.hasAPIEndpointArgsForCall = append(fake.hasAPIEndpointArgsForCall, struct{}{})
	fake.recordInvocation("HasAPIEndpoint", []interface{}{})
	fake.hasAPIEndpointMutex.Unlock()
	if fake.HasAPIEndpointStub != nil {
		return fake.HasAPIEndpointStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.hasAPIEndpointReturns.result1
}

func (fake *FakePluginContext) HasAPIEndpointCallCount() int {
	fake.hasAPIEndpointMutex.RLock()
	defer fake.hasAPIEndpointMutex.RUnlock()
	return len(fake.hasAPIEndpointArgsForCall)
}

func (fake *FakePluginContext) HasAPIEndpointReturns(result1 bool) {
	fake.HasAPIEndpointStub = nil
	fake.hasAPIEndpointReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakePluginContext) HasAPIEndpointReturnsOnCall(i int, result1 bool) {
	fake.HasAPIEndpointStub = nil
	if fake.hasAPIEndpointReturnsOnCall == nil {
		fake.hasAPIEndpointReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.hasAPIEndpointReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakePluginContext) DopplerEndpoint() string {
	fake.dopplerEndpointMutex.Lock()
	ret, specificReturn := fake.dopplerEndpointReturnsOnCall[len(fake.dopplerEndpointArgsForCall)]
	fake.dopplerEndpointArgsForCall = append(fake.dopplerEndpointArgsForCall, struct{}{})
	fake.recordInvocation("DopplerEndpoint", []interface{}{})
	fake.dopplerEndpointMutex.Unlock()
	if fake.DopplerEndpointStub != nil {
		return fake.DopplerEndpointStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.dopplerEndpointReturns.result1
}

func (fake *FakePluginContext) DopplerEndpointCallCount() int {
	fake.dopplerEndpointMutex.RLock()
	defer fake.dopplerEndpointMutex.RUnlock()
	return len(fake.dopplerEndpointArgsForCall)
}

func (fake *FakePluginContext) DopplerEndpointReturns(result1 string) {
	fake.DopplerEndpointStub = nil
	fake.dopplerEndpointReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginContext) DopplerEndpointReturnsOnCall(i int, result1 string) {
	fake.DopplerEndpointStub = nil
	if fake.dopplerEndpointReturnsOnCall == nil {
		fake.dopplerEndpointReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.dopplerEndpointReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginContext) ConsoleEndpoint() string {
	fake.consoleEndpointMutex.Lock()
	ret, specificReturn := fake.consoleEndpointReturnsOnCall[len(fake.consoleEndpointArgsForCall)]
	fake.consoleEndpointArgsForCall = append(fake.consoleEndpointArgsForCall, struct{}{})
	fake.recordInvocation("ConsoleEndpoint", []interface{}{})
	fake.consoleEndpointMutex.Unlock()
	if fake.ConsoleEndpointStub != nil {
		return fake.ConsoleEndpointStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.consoleEndpointReturns.result1
}

func (fake *FakePluginContext) ConsoleEndpointCallCount() int {
	fake.consoleEndpointMutex.RLock()
	defer fake.consoleEndpointMutex.RUnlock()
	return len(fake.consoleEndpointArgsForCall)
}

func (fake *FakePluginContext) ConsoleEndpointReturns(result1 string) {
	fake.ConsoleEndpointStub = nil
	fake.consoleEndpointReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginContext) ConsoleEndpointReturnsOnCall(i int, result1 string) {
	fake.ConsoleEndpointStub = nil
	if fake.consoleEndpointReturnsOnCall == nil {
		fake.consoleEndpointReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.consoleEndpointReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginContext) UAAEndpoint() string {
	fake.uAAEndpointMutex.Lock()
	ret, specificReturn := fake.uAAEndpointReturnsOnCall[len(fake.uAAEndpointArgsForCall)]
	fake.uAAEndpointArgsForCall = append(fake.uAAEndpointArgsForCall, struct{}{})
	fake.recordInvocation("UAAEndpoint", []interface{}{})
	fake.uAAEndpointMutex.Unlock()
	if fake.UAAEndpointStub != nil {
		return fake.UAAEndpointStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.uAAEndpointReturns.result1
}

func (fake *FakePluginContext) UAAEndpointCallCount() int {
	fake.uAAEndpointMutex.RLock()
	defer fake.uAAEndpointMutex.RUnlock()
	return len(fake.uAAEndpointArgsForCall)
}

func (fake *FakePluginContext) UAAEndpointReturns(result1 string) {
	fake.UAAEndpointStub = nil
	fake.uAAEndpointReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginContext) UAAEndpointReturnsOnCall(i int, result1 string) {
	fake.UAAEndpointStub = nil
	if fake.uAAEndpointReturnsOnCall == nil {
		fake.uAAEndpointReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.uAAEndpointReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginContext) UAAToken() string {
	fake.uAATokenMutex.Lock()
	ret, specificReturn := fake.uAATokenReturnsOnCall[len(fake.uAATokenArgsForCall)]
	fake.uAATokenArgsForCall = append(fake.uAATokenArgsForCall, struct{}{})
	fake.recordInvocation("UAAToken", []interface{}{})
	fake.uAATokenMutex.Unlock()
	if fake.UAATokenStub != nil {
		return fake.UAATokenStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.uAATokenReturns.result1
}

func (fake *FakePluginContext) UAATokenCallCount() int {
	fake.uAATokenMutex.RLock()
	defer fake.uAATokenMutex.RUnlock()
	return len(fake.uAATokenArgsForCall)
}

func (fake *FakePluginContext) UAATokenReturns(result1 string) {
	fake.UAATokenStub = nil
	fake.uAATokenReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginContext) UAATokenReturnsOnCall(i int, result1 string) {
	fake.UAATokenStub = nil
	if fake.uAATokenReturnsOnCall == nil {
		fake.uAATokenReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.uAATokenReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginContext) UAARefreshToken() string {
	fake.uAARefreshTokenMutex.Lock()
	ret, specificReturn := fake.uAARefreshTokenReturnsOnCall[len(fake.uAARefreshTokenArgsForCall)]
	fake.uAARefreshTokenArgsForCall = append(fake.uAARefreshTokenArgsForCall, struct{}{})
	fake.recordInvocation("UAARefreshToken", []interface{}{})
	fake.uAARefreshTokenMutex.Unlock()
	if fake.UAARefreshTokenStub != nil {
		return fake.UAARefreshTokenStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.uAARefreshTokenReturns.result1
}

func (fake *FakePluginContext) UAARefreshTokenCallCount() int {
	fake.uAARefreshTokenMutex.RLock()
	defer fake.uAARefreshTokenMutex.RUnlock()
	return len(fake.uAARefreshTokenArgsForCall)
}

func (fake *FakePluginContext) UAARefreshTokenReturns(result1 string) {
	fake.UAARefreshTokenStub = nil
	fake.uAARefreshTokenReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginContext) UAARefreshTokenReturnsOnCall(i int, result1 string) {
	fake.UAARefreshTokenStub = nil
	if fake.uAARefreshTokenReturnsOnCall == nil {
		fake.uAARefreshTokenReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.uAARefreshTokenReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginContext) RefreshUAAToken() (string, error) {
	fake.refreshUAATokenMutex.Lock()
	ret, specificReturn := fake.refreshUAATokenReturnsOnCall[len(fake.refreshUAATokenArgsForCall)]
	fake.refreshUAATokenArgsForCall = append(fake.refreshUAATokenArgsForCall, struct{}{})
	fake.recordInvocation("RefreshUAAToken", []interface{}{})
	fake.refreshUAATokenMutex.Unlock()
	if fake.RefreshUAATokenStub != nil {
		return fake.RefreshUAATokenStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.refreshUAATokenReturns.result1, fake.refreshUAATokenReturns.result2
}

func (fake *FakePluginContext) RefreshUAATokenCallCount() int {
	fake.refreshUAATokenMutex.RLock()
	defer fake.refreshUAATokenMutex.RUnlock()
	return len(fake.refreshUAATokenArgsForCall)
}

func (fake *FakePluginContext) RefreshUAATokenReturns(result1 string, result2 error) {
	fake.RefreshUAATokenStub = nil
	fake.refreshUAATokenReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakePluginContext) RefreshUAATokenReturnsOnCall(i int, result1 string, result2 error) {
	fake.RefreshUAATokenStub = nil
	if fake.refreshUAATokenReturnsOnCall == nil {
		fake.refreshUAATokenReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.refreshUAATokenReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakePluginContext) IAMTokenEndpoint() string {
	fake.iAMTokenEndpointMutex.Lock()
	ret, specificReturn := fake.iAMTokenEndpointReturnsOnCall[len(fake.iAMTokenEndpointArgsForCall)]
	fake.iAMTokenEndpointArgsForCall = append(fake.iAMTokenEndpointArgsForCall, struct{}{})
	fake.recordInvocation("IAMTokenEndpoint", []interface{}{})
	fake.iAMTokenEndpointMutex.Unlock()
	if fake.IAMTokenEndpointStub != nil {
		return fake.IAMTokenEndpointStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.iAMTokenEndpointReturns.result1
}

func (fake *FakePluginContext) IAMTokenEndpointCallCount() int {
	fake.iAMTokenEndpointMutex.RLock()
	defer fake.iAMTokenEndpointMutex.RUnlock()
	return len(fake.iAMTokenEndpointArgsForCall)
}

func (fake *FakePluginContext) IAMTokenEndpointReturns(result1 string) {
	fake.IAMTokenEndpointStub = nil
	fake.iAMTokenEndpointReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginContext) IAMTokenEndpointReturnsOnCall(i int, result1 string) {
	fake.IAMTokenEndpointStub = nil
	if fake.iAMTokenEndpointReturnsOnCall == nil {
		fake.iAMTokenEndpointReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.iAMTokenEndpointReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginContext) IAMToken() string {
	fake.iAMTokenMutex.Lock()
	ret, specificReturn := fake.iAMTokenReturnsOnCall[len(fake.iAMTokenArgsForCall)]
	fake.iAMTokenArgsForCall = append(fake.iAMTokenArgsForCall, struct{}{})
	fake.recordInvocation("IAMToken", []interface{}{})
	fake.iAMTokenMutex.Unlock()
	if fake.IAMTokenStub != nil {
		return fake.IAMTokenStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.iAMTokenReturns.result1
}

func (fake *FakePluginContext) IAMTokenCallCount() int {
	fake.iAMTokenMutex.RLock()
	defer fake.iAMTokenMutex.RUnlock()
	return len(fake.iAMTokenArgsForCall)
}

func (fake *FakePluginContext) IAMTokenReturns(result1 string) {
	fake.IAMTokenStub = nil
	fake.iAMTokenReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginContext) IAMTokenReturnsOnCall(i int, result1 string) {
	fake.IAMTokenStub = nil
	if fake.iAMTokenReturnsOnCall == nil {
		fake.iAMTokenReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.iAMTokenReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginContext) IAMRefreshToken() string {
	fake.iAMRefreshTokenMutex.Lock()
	ret, specificReturn := fake.iAMRefreshTokenReturnsOnCall[len(fake.iAMRefreshTokenArgsForCall)]
	fake.iAMRefreshTokenArgsForCall = append(fake.iAMRefreshTokenArgsForCall, struct{}{})
	fake.recordInvocation("IAMRefreshToken", []interface{}{})
	fake.iAMRefreshTokenMutex.Unlock()
	if fake.IAMRefreshTokenStub != nil {
		return fake.IAMRefreshTokenStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.iAMRefreshTokenReturns.result1
}

func (fake *FakePluginContext) IAMRefreshTokenCallCount() int {
	fake.iAMRefreshTokenMutex.RLock()
	defer fake.iAMRefreshTokenMutex.RUnlock()
	return len(fake.iAMRefreshTokenArgsForCall)
}

func (fake *FakePluginContext) IAMRefreshTokenReturns(result1 string) {
	fake.IAMRefreshTokenStub = nil
	fake.iAMRefreshTokenReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginContext) IAMRefreshTokenReturnsOnCall(i int, result1 string) {
	fake.IAMRefreshTokenStub = nil
	if fake.iAMRefreshTokenReturnsOnCall == nil {
		fake.iAMRefreshTokenReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.iAMRefreshTokenReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginContext) RefreshIAMToken() (string, error) {
	fake.refreshIAMTokenMutex.Lock()
	ret, specificReturn := fake.refreshIAMTokenReturnsOnCall[len(fake.refreshIAMTokenArgsForCall)]
	fake.refreshIAMTokenArgsForCall = append(fake.refreshIAMTokenArgsForCall, struct{}{})
	fake.recordInvocation("RefreshIAMToken", []interface{}{})
	fake.refreshIAMTokenMutex.Unlock()
	if fake.RefreshIAMTokenStub != nil {
		return fake.RefreshIAMTokenStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.refreshIAMTokenReturns.result1, fake.refreshIAMTokenReturns.result2
}

func (fake *FakePluginContext) RefreshIAMTokenCallCount() int {
	fake.refreshIAMTokenMutex.RLock()
	defer fake.refreshIAMTokenMutex.RUnlock()
	return len(fake.refreshIAMTokenArgsForCall)
}

func (fake *FakePluginContext) RefreshIAMTokenReturns(result1 string, result2 error) {
	fake.RefreshIAMTokenStub = nil
	fake.refreshIAMTokenReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakePluginContext) RefreshIAMTokenReturnsOnCall(i int, result1 string, result2 error) {
	fake.RefreshIAMTokenStub = nil
	if fake.refreshIAMTokenReturnsOnCall == nil {
		fake.refreshIAMTokenReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.refreshIAMTokenReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakePluginContext) Username() string {
	fake.usernameMutex.Lock()
	ret, specificReturn := fake.usernameReturnsOnCall[len(fake.usernameArgsForCall)]
	fake.usernameArgsForCall = append(fake.usernameArgsForCall, struct{}{})
	fake.recordInvocation("Username", []interface{}{})
	fake.usernameMutex.Unlock()
	if fake.UsernameStub != nil {
		return fake.UsernameStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.usernameReturns.result1
}

func (fake *FakePluginContext) UsernameCallCount() int {
	fake.usernameMutex.RLock()
	defer fake.usernameMutex.RUnlock()
	return len(fake.usernameArgsForCall)
}

func (fake *FakePluginContext) UsernameReturns(result1 string) {
	fake.UsernameStub = nil
	fake.usernameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginContext) UsernameReturnsOnCall(i int, result1 string) {
	fake.UsernameStub = nil
	if fake.usernameReturnsOnCall == nil {
		fake.usernameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.usernameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginContext) UserGUID() string {
	fake.userGUIDMutex.Lock()
	ret, specificReturn := fake.userGUIDReturnsOnCall[len(fake.userGUIDArgsForCall)]
	fake.userGUIDArgsForCall = append(fake.userGUIDArgsForCall, struct{}{})
	fake.recordInvocation("UserGUID", []interface{}{})
	fake.userGUIDMutex.Unlock()
	if fake.UserGUIDStub != nil {
		return fake.UserGUIDStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.userGUIDReturns.result1
}

func (fake *FakePluginContext) UserGUIDCallCount() int {
	fake.userGUIDMutex.RLock()
	defer fake.userGUIDMutex.RUnlock()
	return len(fake.userGUIDArgsForCall)
}

func (fake *FakePluginContext) UserGUIDReturns(result1 string) {
	fake.UserGUIDStub = nil
	fake.userGUIDReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginContext) UserGUIDReturnsOnCall(i int, result1 string) {
	fake.UserGUIDStub = nil
	if fake.userGUIDReturnsOnCall == nil {
		fake.userGUIDReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.userGUIDReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginContext) UserEmail() string {
	fake.userEmailMutex.Lock()
	ret, specificReturn := fake.userEmailReturnsOnCall[len(fake.userEmailArgsForCall)]
	fake.userEmailArgsForCall = append(fake.userEmailArgsForCall, struct{}{})
	fake.recordInvocation("UserEmail", []interface{}{})
	fake.userEmailMutex.Unlock()
	if fake.UserEmailStub != nil {
		return fake.UserEmailStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.userEmailReturns.result1
}

func (fake *FakePluginContext) UserEmailCallCount() int {
	fake.userEmailMutex.RLock()
	defer fake.userEmailMutex.RUnlock()
	return len(fake.userEmailArgsForCall)
}

func (fake *FakePluginContext) UserEmailReturns(result1 string) {
	fake.UserEmailStub = nil
	fake.userEmailReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginContext) UserEmailReturnsOnCall(i int, result1 string) {
	fake.UserEmailStub = nil
	if fake.userEmailReturnsOnCall == nil {
		fake.userEmailReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.userEmailReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginContext) IsLoggedIn() bool {
	fake.isLoggedInMutex.Lock()
	ret, specificReturn := fake.isLoggedInReturnsOnCall[len(fake.isLoggedInArgsForCall)]
	fake.isLoggedInArgsForCall = append(fake.isLoggedInArgsForCall, struct{}{})
	fake.recordInvocation("IsLoggedIn", []interface{}{})
	fake.isLoggedInMutex.Unlock()
	if fake.IsLoggedInStub != nil {
		return fake.IsLoggedInStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.isLoggedInReturns.result1
}

func (fake *FakePluginContext) IsLoggedInCallCount() int {
	fake.isLoggedInMutex.RLock()
	defer fake.isLoggedInMutex.RUnlock()
	return len(fake.isLoggedInArgsForCall)
}

func (fake *FakePluginContext) IsLoggedInReturns(result1 bool) {
	fake.IsLoggedInStub = nil
	fake.isLoggedInReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakePluginContext) IsLoggedInReturnsOnCall(i int, result1 bool) {
	fake.IsLoggedInStub = nil
	if fake.isLoggedInReturnsOnCall == nil {
		fake.isLoggedInReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isLoggedInReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakePluginContext) CurrentOrg() models.OrganizationFields {
	fake.currentOrgMutex.Lock()
	ret, specificReturn := fake.currentOrgReturnsOnCall[len(fake.currentOrgArgsForCall)]
	fake.currentOrgArgsForCall = append(fake.currentOrgArgsForCall, struct{}{})
	fake.recordInvocation("CurrentOrg", []interface{}{})
	fake.currentOrgMutex.Unlock()
	if fake.CurrentOrgStub != nil {
		return fake.CurrentOrgStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.currentOrgReturns.result1
}

func (fake *FakePluginContext) CurrentOrgCallCount() int {
	fake.currentOrgMutex.RLock()
	defer fake.currentOrgMutex.RUnlock()
	return len(fake.currentOrgArgsForCall)
}

func (fake *FakePluginContext) CurrentOrgReturns(result1 models.OrganizationFields) {
	fake.CurrentOrgStub = nil
	fake.currentOrgReturns = struct {
		result1 models.OrganizationFields
	}{result1}
}

func (fake *FakePluginContext) CurrentOrgReturnsOnCall(i int, result1 models.OrganizationFields) {
	fake.CurrentOrgStub = nil
	if fake.currentOrgReturnsOnCall == nil {
		fake.currentOrgReturnsOnCall = make(map[int]struct {
			result1 models.OrganizationFields
		})
	}
	fake.currentOrgReturnsOnCall[i] = struct {
		result1 models.OrganizationFields
	}{result1}
}

func (fake *FakePluginContext) HasOrganization() bool {
	fake.hasOrganizationMutex.Lock()
	ret, specificReturn := fake.hasOrganizationReturnsOnCall[len(fake.hasOrganizationArgsForCall)]
	fake.hasOrganizationArgsForCall = append(fake.hasOrganizationArgsForCall, struct{}{})
	fake.recordInvocation("HasOrganization", []interface{}{})
	fake.hasOrganizationMutex.Unlock()
	if fake.HasOrganizationStub != nil {
		return fake.HasOrganizationStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.hasOrganizationReturns.result1
}

func (fake *FakePluginContext) HasOrganizationCallCount() int {
	fake.hasOrganizationMutex.RLock()
	defer fake.hasOrganizationMutex.RUnlock()
	return len(fake.hasOrganizationArgsForCall)
}

func (fake *FakePluginContext) HasOrganizationReturns(result1 bool) {
	fake.HasOrganizationStub = nil
	fake.hasOrganizationReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakePluginContext) HasOrganizationReturnsOnCall(i int, result1 bool) {
	fake.HasOrganizationStub = nil
	if fake.hasOrganizationReturnsOnCall == nil {
		fake.hasOrganizationReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.hasOrganizationReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakePluginContext) AccountID() string {
	fake.accountIDMutex.Lock()
	ret, specificReturn := fake.accountIDReturnsOnCall[len(fake.accountIDArgsForCall)]
	fake.accountIDArgsForCall = append(fake.accountIDArgsForCall, struct{}{})
	fake.recordInvocation("AccountID", []interface{}{})
	fake.accountIDMutex.Unlock()
	if fake.AccountIDStub != nil {
		return fake.AccountIDStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.accountIDReturns.result1
}

func (fake *FakePluginContext) AccountIDCallCount() int {
	fake.accountIDMutex.RLock()
	defer fake.accountIDMutex.RUnlock()
	return len(fake.accountIDArgsForCall)
}

func (fake *FakePluginContext) AccountIDReturns(result1 string) {
	fake.AccountIDStub = nil
	fake.accountIDReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginContext) AccountIDReturnsOnCall(i int, result1 string) {
	fake.AccountIDStub = nil
	if fake.accountIDReturnsOnCall == nil {
		fake.accountIDReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.accountIDReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginContext) Account() models.Account {
	fake.accountMutex.Lock()
	ret, specificReturn := fake.accountReturnsOnCall[len(fake.accountArgsForCall)]
	fake.accountArgsForCall = append(fake.accountArgsForCall, struct{}{})
	fake.recordInvocation("Account", []interface{}{})
	fake.accountMutex.Unlock()
	if fake.AccountStub != nil {
		return fake.AccountStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.accountReturns.result1
}

func (fake *FakePluginContext) AccountCallCount() int {
	fake.accountMutex.RLock()
	defer fake.accountMutex.RUnlock()
	return len(fake.accountArgsForCall)
}

func (fake *FakePluginContext) AccountReturns(result1 models.Account) {
	fake.AccountStub = nil
	fake.accountReturns = struct {
		result1 models.Account
	}{result1}
}

func (fake *FakePluginContext) AccountReturnsOnCall(i int, result1 models.Account) {
	fake.AccountStub = nil
	if fake.accountReturnsOnCall == nil {
		fake.accountReturnsOnCall = make(map[int]struct {
			result1 models.Account
		})
	}
	fake.accountReturnsOnCall[i] = struct {
		result1 models.Account
	}{result1}
}

func (fake *FakePluginContext) IMSAccountID() string {
	fake.iMSAccountIDMutex.Lock()
	ret, specificReturn := fake.iMSAccountIDReturnsOnCall[len(fake.iMSAccountIDArgsForCall)]
	fake.iMSAccountIDArgsForCall = append(fake.iMSAccountIDArgsForCall, struct{}{})
	fake.recordInvocation("IMSAccountID", []interface{}{})
	fake.iMSAccountIDMutex.Unlock()
	if fake.IMSAccountIDStub != nil {
		return fake.IMSAccountIDStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.iMSAccountIDReturns.result1
}

func (fake *FakePluginContext) IMSAccountIDCallCount() int {
	fake.iMSAccountIDMutex.RLock()
	defer fake.iMSAccountIDMutex.RUnlock()
	return len(fake.iMSAccountIDArgsForCall)
}

func (fake *FakePluginContext) IMSAccountIDReturns(result1 string) {
	fake.IMSAccountIDStub = nil
	fake.iMSAccountIDReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginContext) IMSAccountIDReturnsOnCall(i int, result1 string) {
	fake.IMSAccountIDStub = nil
	if fake.iMSAccountIDReturnsOnCall == nil {
		fake.iMSAccountIDReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.iMSAccountIDReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginContext) ResourceGroup() models.ResourceGroup {
	fake.resourceGroupMutex.Lock()
	ret, specificReturn := fake.resourceGroupReturnsOnCall[len(fake.resourceGroupArgsForCall)]
	fake.resourceGroupArgsForCall = append(fake.resourceGroupArgsForCall, struct{}{})
	fake.recordInvocation("ResourceGroup", []interface{}{})
	fake.resourceGroupMutex.Unlock()
	if fake.ResourceGroupStub != nil {
		return fake.ResourceGroupStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.resourceGroupReturns.result1
}

func (fake *FakePluginContext) ResourceGroupCallCount() int {
	fake.resourceGroupMutex.RLock()
	defer fake.resourceGroupMutex.RUnlock()
	return len(fake.resourceGroupArgsForCall)
}

func (fake *FakePluginContext) ResourceGroupReturns(result1 models.ResourceGroup) {
	fake.ResourceGroupStub = nil
	fake.resourceGroupReturns = struct {
		result1 models.ResourceGroup
	}{result1}
}

func (fake *FakePluginContext) ResourceGroupReturnsOnCall(i int, result1 models.ResourceGroup) {
	fake.ResourceGroupStub = nil
	if fake.resourceGroupReturnsOnCall == nil {
		fake.resourceGroupReturnsOnCall = make(map[int]struct {
			result1 models.ResourceGroup
		})
	}
	fake.resourceGroupReturnsOnCall[i] = struct {
		result1 models.ResourceGroup
	}{result1}
}

func (fake *FakePluginContext) CurrentSpace() models.SpaceFields {
	fake.currentSpaceMutex.Lock()
	ret, specificReturn := fake.currentSpaceReturnsOnCall[len(fake.currentSpaceArgsForCall)]
	fake.currentSpaceArgsForCall = append(fake.currentSpaceArgsForCall, struct{}{})
	fake.recordInvocation("CurrentSpace", []interface{}{})
	fake.currentSpaceMutex.Unlock()
	if fake.CurrentSpaceStub != nil {
		return fake.CurrentSpaceStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.currentSpaceReturns.result1
}

func (fake *FakePluginContext) CurrentSpaceCallCount() int {
	fake.currentSpaceMutex.RLock()
	defer fake.currentSpaceMutex.RUnlock()
	return len(fake.currentSpaceArgsForCall)
}

func (fake *FakePluginContext) CurrentSpaceReturns(result1 models.SpaceFields) {
	fake.CurrentSpaceStub = nil
	fake.currentSpaceReturns = struct {
		result1 models.SpaceFields
	}{result1}
}

func (fake *FakePluginContext) CurrentSpaceReturnsOnCall(i int, result1 models.SpaceFields) {
	fake.CurrentSpaceStub = nil
	if fake.currentSpaceReturnsOnCall == nil {
		fake.currentSpaceReturnsOnCall = make(map[int]struct {
			result1 models.SpaceFields
		})
	}
	fake.currentSpaceReturnsOnCall[i] = struct {
		result1 models.SpaceFields
	}{result1}
}

func (fake *FakePluginContext) HasSpace() bool {
	fake.hasSpaceMutex.Lock()
	ret, specificReturn := fake.hasSpaceReturnsOnCall[len(fake.hasSpaceArgsForCall)]
	fake.hasSpaceArgsForCall = append(fake.hasSpaceArgsForCall, struct{}{})
	fake.recordInvocation("HasSpace", []interface{}{})
	fake.hasSpaceMutex.Unlock()
	if fake.HasSpaceStub != nil {
		return fake.HasSpaceStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.hasSpaceReturns.result1
}

func (fake *FakePluginContext) HasSpaceCallCount() int {
	fake.hasSpaceMutex.RLock()
	defer fake.hasSpaceMutex.RUnlock()
	return len(fake.hasSpaceArgsForCall)
}

func (fake *FakePluginContext) HasSpaceReturns(result1 bool) {
	fake.HasSpaceStub = nil
	fake.hasSpaceReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakePluginContext) HasSpaceReturnsOnCall(i int, result1 bool) {
	fake.HasSpaceStub = nil
	if fake.hasSpaceReturnsOnCall == nil {
		fake.hasSpaceReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.hasSpaceReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakePluginContext) Region() string {
	fake.regionMutex.Lock()
	ret, specificReturn := fake.regionReturnsOnCall[len(fake.regionArgsForCall)]
	fake.regionArgsForCall = append(fake.regionArgsForCall, struct{}{})
	fake.recordInvocation("Region", []interface{}{})
	fake.regionMutex.Unlock()
	if fake.RegionStub != nil {
		return fake.RegionStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.regionReturns.result1
}

func (fake *FakePluginContext) RegionCallCount() int {
	fake.regionMutex.RLock()
	defer fake.regionMutex.RUnlock()
	return len(fake.regionArgsForCall)
}

func (fake *FakePluginContext) RegionReturns(result1 string) {
	fake.RegionStub = nil
	fake.regionReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginContext) RegionReturnsOnCall(i int, result1 string) {
	fake.RegionStub = nil
	if fake.regionReturnsOnCall == nil {
		fake.regionReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.regionReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginContext) RegionID() string {
	fake.regionIDMutex.Lock()
	ret, specificReturn := fake.regionIDReturnsOnCall[len(fake.regionIDArgsForCall)]
	fake.regionIDArgsForCall = append(fake.regionIDArgsForCall, struct{}{})
	fake.recordInvocation("RegionID", []interface{}{})
	fake.regionIDMutex.Unlock()
	if fake.RegionIDStub != nil {
		return fake.RegionIDStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.regionIDReturns.result1
}

func (fake *FakePluginContext) RegionIDCallCount() int {
	fake.regionIDMutex.RLock()
	defer fake.regionIDMutex.RUnlock()
	return len(fake.regionIDArgsForCall)
}

func (fake *FakePluginContext) RegionIDReturns(result1 string) {
	fake.RegionIDStub = nil
	fake.regionIDReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginContext) RegionIDReturnsOnCall(i int, result1 string) {
	fake.RegionIDStub = nil
	if fake.regionIDReturnsOnCall == nil {
		fake.regionIDReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.regionIDReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginContext) Locale() string {
	fake.localeMutex.Lock()
	ret, specificReturn := fake.localeReturnsOnCall[len(fake.localeArgsForCall)]
	fake.localeArgsForCall = append(fake.localeArgsForCall, struct{}{})
	fake.recordInvocation("Locale", []interface{}{})
	fake.localeMutex.Unlock()
	if fake.LocaleStub != nil {
		return fake.LocaleStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.localeReturns.result1
}

func (fake *FakePluginContext) LocaleCallCount() int {
	fake.localeMutex.RLock()
	defer fake.localeMutex.RUnlock()
	return len(fake.localeArgsForCall)
}

func (fake *FakePluginContext) LocaleReturns(result1 string) {
	fake.LocaleStub = nil
	fake.localeReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginContext) LocaleReturnsOnCall(i int, result1 string) {
	fake.LocaleStub = nil
	if fake.localeReturnsOnCall == nil {
		fake.localeReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.localeReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginContext) Trace() string {
	fake.traceMutex.Lock()
	ret, specificReturn := fake.traceReturnsOnCall[len(fake.traceArgsForCall)]
	fake.traceArgsForCall = append(fake.traceArgsForCall, struct{}{})
	fake.recordInvocation("Trace", []interface{}{})
	fake.traceMutex.Unlock()
	if fake.TraceStub != nil {
		return fake.TraceStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.traceReturns.result1
}

func (fake *FakePluginContext) TraceCallCount() int {
	fake.traceMutex.RLock()
	defer fake.traceMutex.RUnlock()
	return len(fake.traceArgsForCall)
}

func (fake *FakePluginContext) TraceReturns(result1 string) {
	fake.TraceStub = nil
	fake.traceReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginContext) TraceReturnsOnCall(i int, result1 string) {
	fake.TraceStub = nil
	if fake.traceReturnsOnCall == nil {
		fake.traceReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.traceReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginContext) ColorEnabled() string {
	fake.colorEnabledMutex.Lock()
	ret, specificReturn := fake.colorEnabledReturnsOnCall[len(fake.colorEnabledArgsForCall)]
	fake.colorEnabledArgsForCall = append(fake.colorEnabledArgsForCall, struct{}{})
	fake.recordInvocation("ColorEnabled", []interface{}{})
	fake.colorEnabledMutex.Unlock()
	if fake.ColorEnabledStub != nil {
		return fake.ColorEnabledStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.colorEnabledReturns.result1
}

func (fake *FakePluginContext) ColorEnabledCallCount() int {
	fake.colorEnabledMutex.RLock()
	defer fake.colorEnabledMutex.RUnlock()
	return len(fake.colorEnabledArgsForCall)
}

func (fake *FakePluginContext) ColorEnabledReturns(result1 string) {
	fake.ColorEnabledStub = nil
	fake.colorEnabledReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginContext) ColorEnabledReturnsOnCall(i int, result1 string) {
	fake.ColorEnabledStub = nil
	if fake.colorEnabledReturnsOnCall == nil {
		fake.colorEnabledReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.colorEnabledReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginContext) IsSSLDisabled() bool {
	fake.isSSLDisabledMutex.Lock()
	ret, specificReturn := fake.isSSLDisabledReturnsOnCall[len(fake.isSSLDisabledArgsForCall)]
	fake.isSSLDisabledArgsForCall = append(fake.isSSLDisabledArgsForCall, struct{}{})
	fake.recordInvocation("IsSSLDisabled", []interface{}{})
	fake.isSSLDisabledMutex.Unlock()
	if fake.IsSSLDisabledStub != nil {
		return fake.IsSSLDisabledStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.isSSLDisabledReturns.result1
}

func (fake *FakePluginContext) IsSSLDisabledCallCount() int {
	fake.isSSLDisabledMutex.RLock()
	defer fake.isSSLDisabledMutex.RUnlock()
	return len(fake.isSSLDisabledArgsForCall)
}

func (fake *FakePluginContext) IsSSLDisabledReturns(result1 bool) {
	fake.IsSSLDisabledStub = nil
	fake.isSSLDisabledReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakePluginContext) IsSSLDisabledReturnsOnCall(i int, result1 bool) {
	fake.IsSSLDisabledStub = nil
	if fake.isSSLDisabledReturnsOnCall == nil {
		fake.isSSLDisabledReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isSSLDisabledReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakePluginContext) PluginDirectory() string {
	fake.pluginDirectoryMutex.Lock()
	ret, specificReturn := fake.pluginDirectoryReturnsOnCall[len(fake.pluginDirectoryArgsForCall)]
	fake.pluginDirectoryArgsForCall = append(fake.pluginDirectoryArgsForCall, struct{}{})
	fake.recordInvocation("PluginDirectory", []interface{}{})
	fake.pluginDirectoryMutex.Unlock()
	if fake.PluginDirectoryStub != nil {
		return fake.PluginDirectoryStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.pluginDirectoryReturns.result1
}

func (fake *FakePluginContext) PluginDirectoryCallCount() int {
	fake.pluginDirectoryMutex.RLock()
	defer fake.pluginDirectoryMutex.RUnlock()
	return len(fake.pluginDirectoryArgsForCall)
}

func (fake *FakePluginContext) PluginDirectoryReturns(result1 string) {
	fake.PluginDirectoryStub = nil
	fake.pluginDirectoryReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginContext) PluginDirectoryReturnsOnCall(i int, result1 string) {
	fake.PluginDirectoryStub = nil
	if fake.pluginDirectoryReturnsOnCall == nil {
		fake.pluginDirectoryReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.pluginDirectoryReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginContext) HTTPTimeout() int {
	fake.hTTPTimeoutMutex.Lock()
	ret, specificReturn := fake.hTTPTimeoutReturnsOnCall[len(fake.hTTPTimeoutArgsForCall)]
	fake.hTTPTimeoutArgsForCall = append(fake.hTTPTimeoutArgsForCall, struct{}{})
	fake.recordInvocation("HTTPTimeout", []interface{}{})
	fake.hTTPTimeoutMutex.Unlock()
	if fake.HTTPTimeoutStub != nil {
		return fake.HTTPTimeoutStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.hTTPTimeoutReturns.result1
}

func (fake *FakePluginContext) HTTPTimeoutCallCount() int {
	fake.hTTPTimeoutMutex.RLock()
	defer fake.hTTPTimeoutMutex.RUnlock()
	return len(fake.hTTPTimeoutArgsForCall)
}

func (fake *FakePluginContext) HTTPTimeoutReturns(result1 int) {
	fake.HTTPTimeoutStub = nil
	fake.hTTPTimeoutReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakePluginContext) HTTPTimeoutReturnsOnCall(i int, result1 int) {
	fake.HTTPTimeoutStub = nil
	if fake.hTTPTimeoutReturnsOnCall == nil {
		fake.hTTPTimeoutReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.hTTPTimeoutReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakePluginContext) VersionCheckEnabled() bool {
	fake.versionCheckEnabledMutex.Lock()
	ret, specificReturn := fake.versionCheckEnabledReturnsOnCall[len(fake.versionCheckEnabledArgsForCall)]
	fake.versionCheckEnabledArgsForCall = append(fake.versionCheckEnabledArgsForCall, struct{}{})
	fake.recordInvocation("VersionCheckEnabled", []interface{}{})
	fake.versionCheckEnabledMutex.Unlock()
	if fake.VersionCheckEnabledStub != nil {
		return fake.VersionCheckEnabledStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.versionCheckEnabledReturns.result1
}

func (fake *FakePluginContext) VersionCheckEnabledCallCount() int {
	fake.versionCheckEnabledMutex.RLock()
	defer fake.versionCheckEnabledMutex.RUnlock()
	return len(fake.versionCheckEnabledArgsForCall)
}

func (fake *FakePluginContext) VersionCheckEnabledReturns(result1 bool) {
	fake.VersionCheckEnabledStub = nil
	fake.versionCheckEnabledReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakePluginContext) VersionCheckEnabledReturnsOnCall(i int, result1 bool) {
	fake.VersionCheckEnabledStub = nil
	if fake.versionCheckEnabledReturnsOnCall == nil {
		fake.versionCheckEnabledReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.versionCheckEnabledReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakePluginContext) PluginConfig() plugin.PluginConfig {
	fake.pluginConfigMutex.Lock()
	ret, specificReturn := fake.pluginConfigReturnsOnCall[len(fake.pluginConfigArgsForCall)]
	fake.pluginConfigArgsForCall = append(fake.pluginConfigArgsForCall, struct{}{})
	fake.recordInvocation("PluginConfig", []interface{}{})
	fake.pluginConfigMutex.Unlock()
	if fake.PluginConfigStub != nil {
		return fake.PluginConfigStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.pluginConfigReturns.result1
}

func (fake *FakePluginContext) PluginConfigCallCount() int {
	fake.pluginConfigMutex.RLock()
	defer fake.pluginConfigMutex.RUnlock()
	return len(fake.pluginConfigArgsForCall)
}

func (fake *FakePluginContext) PluginConfigReturns(result1 plugin.PluginConfig) {
	fake.PluginConfigStub = nil
	fake.pluginConfigReturns = struct {
		result1 plugin.PluginConfig
	}{result1}
}

func (fake *FakePluginContext) PluginConfigReturnsOnCall(i int, result1 plugin.PluginConfig) {
	fake.PluginConfigStub = nil
	if fake.pluginConfigReturnsOnCall == nil {
		fake.pluginConfigReturnsOnCall = make(map[int]struct {
			result1 plugin.PluginConfig
		})
	}
	fake.pluginConfigReturnsOnCall[i] = struct {
		result1 plugin.PluginConfig
	}{result1}
}

func (fake *FakePluginContext) CommandNamespace() string {
	fake.commandNamespaceMutex.Lock()
	ret, specificReturn := fake.commandNamespaceReturnsOnCall[len(fake.commandNamespaceArgsForCall)]
	fake.commandNamespaceArgsForCall = append(fake.commandNamespaceArgsForCall, struct{}{})
	fake.recordInvocation("CommandNamespace", []interface{}{})
	fake.commandNamespaceMutex.Unlock()
	if fake.CommandNamespaceStub != nil {
		return fake.CommandNamespaceStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.commandNamespaceReturns.result1
}

func (fake *FakePluginContext) CommandNamespaceCallCount() int {
	fake.commandNamespaceMutex.RLock()
	defer fake.commandNamespaceMutex.RUnlock()
	return len(fake.commandNamespaceArgsForCall)
}

func (fake *FakePluginContext) CommandNamespaceReturns(result1 string) {
	fake.CommandNamespaceStub = nil
	fake.commandNamespaceReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginContext) CommandNamespaceReturnsOnCall(i int, result1 string) {
	fake.CommandNamespaceStub = nil
	if fake.commandNamespaceReturnsOnCall == nil {
		fake.commandNamespaceReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.commandNamespaceReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginContext) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.aPIVersionMutex.RLock()
	defer fake.aPIVersionMutex.RUnlock()
	fake.aPIEndpointMutex.RLock()
	defer fake.aPIEndpointMutex.RUnlock()
	fake.hasAPIEndpointMutex.RLock()
	defer fake.hasAPIEndpointMutex.RUnlock()
	fake.dopplerEndpointMutex.RLock()
	defer fake.dopplerEndpointMutex.RUnlock()
	fake.consoleEndpointMutex.RLock()
	defer fake.consoleEndpointMutex.RUnlock()
	fake.uAAEndpointMutex.RLock()
	defer fake.uAAEndpointMutex.RUnlock()
	fake.uAATokenMutex.RLock()
	defer fake.uAATokenMutex.RUnlock()
	fake.uAARefreshTokenMutex.RLock()
	defer fake.uAARefreshTokenMutex.RUnlock()
	fake.refreshUAATokenMutex.RLock()
	defer fake.refreshUAATokenMutex.RUnlock()
	fake.iAMTokenEndpointMutex.RLock()
	defer fake.iAMTokenEndpointMutex.RUnlock()
	fake.iAMTokenMutex.RLock()
	defer fake.iAMTokenMutex.RUnlock()
	fake.iAMRefreshTokenMutex.RLock()
	defer fake.iAMRefreshTokenMutex.RUnlock()
	fake.refreshIAMTokenMutex.RLock()
	defer fake.refreshIAMTokenMutex.RUnlock()
	fake.usernameMutex.RLock()
	defer fake.usernameMutex.RUnlock()
	fake.userGUIDMutex.RLock()
	defer fake.userGUIDMutex.RUnlock()
	fake.userEmailMutex.RLock()
	defer fake.userEmailMutex.RUnlock()
	fake.isLoggedInMutex.RLock()
	defer fake.isLoggedInMutex.RUnlock()
	fake.currentOrgMutex.RLock()
	defer fake.currentOrgMutex.RUnlock()
	fake.hasOrganizationMutex.RLock()
	defer fake.hasOrganizationMutex.RUnlock()
	fake.accountIDMutex.RLock()
	defer fake.accountIDMutex.RUnlock()
	fake.accountMutex.RLock()
	defer fake.accountMutex.RUnlock()
	fake.iMSAccountIDMutex.RLock()
	defer fake.iMSAccountIDMutex.RUnlock()
	fake.resourceGroupMutex.RLock()
	defer fake.resourceGroupMutex.RUnlock()
	fake.currentSpaceMutex.RLock()
	defer fake.currentSpaceMutex.RUnlock()
	fake.hasSpaceMutex.RLock()
	defer fake.hasSpaceMutex.RUnlock()
	fake.regionMutex.RLock()
	defer fake.regionMutex.RUnlock()
	fake.regionIDMutex.RLock()
	defer fake.regionIDMutex.RUnlock()
	fake.localeMutex.RLock()
	defer fake.localeMutex.RUnlock()
	fake.traceMutex.RLock()
	defer fake.traceMutex.RUnlock()
	fake.colorEnabledMutex.RLock()
	defer fake.colorEnabledMutex.RUnlock()
	fake.isSSLDisabledMutex.RLock()
	defer fake.isSSLDisabledMutex.RUnlock()
	fake.pluginDirectoryMutex.RLock()
	defer fake.pluginDirectoryMutex.RUnlock()
	fake.hTTPTimeoutMutex.RLock()
	defer fake.hTTPTimeoutMutex.RUnlock()
	fake.versionCheckEnabledMutex.RLock()
	defer fake.versionCheckEnabledMutex.RUnlock()
	fake.pluginConfigMutex.RLock()
	defer fake.pluginConfigMutex.RUnlock()
	fake.commandNamespaceMutex.RLock()
	defer fake.commandNamespaceMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakePluginContext) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ plugin.PluginContext = new(FakePluginContext)
